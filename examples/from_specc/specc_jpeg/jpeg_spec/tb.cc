//////////////////////////////////////////////////////////////////////
// C++ source file generated by SCRC V2.1
// Design: tb
// File:   tb.cc
// Time:   Sat Mar 22 17:49:30 2008
//////////////////////////////////////////////////////////////////////

#include "tb.h"

// variable definitions //////////////////////////////////////////////

#line 12 "./default.sc"
static const int LuminanceDCBits[16] = { 
  0,1,5,1,1,1,1,1,
  1,0,0,0,0,0,0,0 };

static const int LuminanceDCValues[162] = { 
  0,1,2,3,4,5,6,7,8,9,10,11 };

static const int LuminanceACBits[16] = { 
  0,2,1,3,3,2,4,3,
  5,5,4,4,0,0,1,125 };

static const int LuminanceACValues[162] = { 
  1,2,3,0,4,17,5,18,
  33,49,65,6,19,81,97,7,
  34,113,20,50,129,145,161,8,
  35,66,177,193,21,82,209,240,
  36,51,98,114,130,9,10,22,
  23,24,25,26,37,38,39,40,
  41,42,52,53,54,55,56,57,
  58,67,68,69,70,71,72,73,
  74,83,84,85,86,87,88,89,
  90,99,100,101,102,103,104,105,
  106,115,116,117,118,119,120,121,
  122,131,132,133,134,135,136,137,
  138,146,147,148,149,150,151,152,
  153,154,162,163,164,165,166,167,
  168,169,170,178,179,180,181,182,
  183,184,185,186,194,195,196,197,
  198,199,200,201,202,210,211,212,
  213,214,215,216,217,218,225,226,
  227,228,229,230,231,232,233,234,
  241,242,243,244,245,246,247,248,
  249,250 };

#line 17 "./global.sc"
const int QuantizationMatrix[64] = { 
  16,11,10,16,24,40,51,61,
  12,12,14,19,26,58,60,55,
  14,13,16,24,40,57,69,56,
  14,17,22,29,51,87,80,62,
  18,22,37,56,68,109,103,77,
  24,35,55,64,81,104,113,92,
  49,64,78,87,103,121,120,101,
  72,92,95,98,112,100,103,99 };

#line 12 "./header.sc"
static const int IZigzagIndex[] = { 
  0,1,8,16,9,2,3,10,
  17,24,32,25,18,11,4,5,
  12,19,26,33,40,48,41,34,
  27,20,13,6,7,14,21,28,
  35,42,49,56,57,50,43,36,
  29,22,15,23,30,37,44,51,
  58,59,52,45,38,31,39,46,
  53,60,61,54,47,55,62,63 };

#line 22 "./huff.sc"
static const int csize[] = { 
  0,
  1,
  2,2,
  3,3,3,3,
  4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8 };


static const int ZigzagIndex[] = { 
  0,1,5,6,14,15,27,28,
  2,4,7,13,16,26,29,42,
  3,8,12,17,25,30,41,43,
  9,11,18,24,31,40,44,53,
  10,19,23,32,39,45,52,54,
  20,22,33,38,46,51,55,60,
  21,34,37,47,50,56,59,61,
  35,36,48,49,57,58,62,63 };

// channel class definitions /////////////////////////////////////////

#line 106 "tb.cc"
CBitAdapter::CBitAdapter(i_byte_sender (&chData))
    : chData(chData),
    left_bits(8),
    write_byte(((unsigned char)'\000'))
{   /* nothing */
}

CBitAdapter::~CBitAdapter(void)
{   /* nothing */
}

#line 43 "./adapter.sc"
void CBitAdapter::FlushBits(void)
{   



    chData.send(write_byte);
    if (write_byte == 255) {



	chData.send(0);
    }
}

#line 61 "./adapter.sc"
int CBitAdapter::WriteBits(int n, int code)
{   
    int p;

    unsigned int lmask[] = { 
      0u,
      1u,3u,7u,15u,
      31u,63u,127u,255u,
      511u,1023u,2047u,4095u,
      8191u,16383u,32767u,65535u };



    if (n < 0)
    {   
	if (left_bits < 8) {
	    n = left_bits;
	    FlushBits();
	    write_byte = 0;
	    left_bits = 8;
	}
	else 
	    n = 0;

	return n;
    }

    code &= lmask[n];
    p = n - left_bits;

    if (n == left_bits) {
	write_byte |= code;
	FlushBits();
	write_byte = 0;
	left_bits = 8;
    }
    else  if (n > left_bits) {
	    write_byte |= (code >> p);
	    FlushBits();
	    if (p > 8) {
		write_byte = (255 & (code >> (p - 8)));
		FlushBits();
		p -= 8;
	    }

	    write_byte = (code & lmask[p]) << (8 - p);
	    left_bits = 8 - p;
	}
	else  {
	    write_byte |= (code <<  -p);
	    left_bits -= n;
	}

    return n;
}

#line 31 "./adapter.sc"
int CBitAdapter::WriteByte(int code)
{   
    chData.send((char)code);
    return 0;
}

void CBitAdapter::WriteMarker(int m)
{   
    chData.send(255);
    chData.send((char)m);
}

#line 24 "./adapter.sc"
int CBitAdapter::WriteWord(int code)
{   
    chData.send((char)(code >> 8));
    chData.send((char)(code & 255));
    return 2;
}

#line 211 "tb.cc"
c_byte_double_handshake::c_byte_double_handshake(void)
    : v(false),
    w(false)
{   /* nothing */
}

c_byte_double_handshake::~c_byte_double_handshake(void)
{   /* nothing */
}

#line 26 "./chann.sc"
void c_byte_double_handshake::receive(char *d) { if ( !v) { w = true; _specc::wait(event(&req), ((void*)0)); w = false;
    }

#line 26 "./chann.sc"
     *d = tmpd; v = false; _specc::notify(event(&ack), ((void*)0)); _specc::wait(event(&ack), ((void*)0));
}

#line 26 "./chann.sc"
void c_byte_double_handshake::send(char d) { tmpd = d; v = true; if (w) { _specc::notify(event(&req), ((void*)0));
    }

#line 26 "./chann.sc"
    _specc::wait(event(&ack), ((void*)0));
}

#line 238 "tb.cc"
c_int_double_handshake::c_int_double_handshake(void)
    : v(false),
    w(false)
{   /* nothing */
}

c_int_double_handshake::~c_int_double_handshake(void)
{   /* nothing */
}

#line 36 "./chann.sc"
void c_int_double_handshake::receive(int *d) { if ( !v) { w = true; _specc::wait(event(&req), ((void*)0)); w = false;
    }

#line 36 "./chann.sc"
     *d = tmpd; v = false; _specc::notify(event(&ack), ((void*)0)); _specc::wait(event(&ack), ((void*)0));
}

#line 36 "./chann.sc"
void c_int_double_handshake::send(int d) { tmpd = d; v = true; if (w) { _specc::notify(event(&req), ((void*)0));
    }

#line 36 "./chann.sc"
    _specc::wait(event(&ack), ((void*)0));
}

#line 265 "tb.cc"
c_block_double_handshake::c_block_double_handshake(void)
    : v(false),
    w(false)
{   /* nothing */
}

c_block_double_handshake::~c_block_double_handshake(void)
{   /* nothing */
}

#line 48 "./chann.sc"
void c_block_double_handshake::receive(int (*d)[64]) { if ( !v) { w = true; _specc::wait(event(&req), ((void*)0)); w = false;
    }

#line 48 "./chann.sc"
    { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<64;_scc_index_0++) ( *d)[_scc_index_0] = (tmpd)[_scc_index_0]; } v = false; _specc::notify(event(&ack), ((void*)0)); _specc::wait(event(&ack), ((void*)0));
}

#line 48 "./chann.sc"
void c_block_double_handshake::send(int d[64]) { { unsigned int _scc_index_0; for(_scc_index_0=0;_scc_index_0<64;_scc_index_0++) (tmpd)[_scc_index_0] = (d)[_scc_index_0]; } v = true; if (w) { _specc::notify(event(&req), ((void*)0));
    }

#line 48 "./chann.sc"
    _specc::wait(event(&ack), ((void*)0));
}

// behavior class definitions ////////////////////////////////////////

#line 294 "tb.cc"
ChenDct::ChenDct(int (&x)[64], int (&y)[64])
    : x(x), y(y)
{   /* nothing */
}

ChenDct::~ChenDct(void)
{   /* nothing */
}

#line 63 "./dct.sc"
void ChenDct::main(void)
{   
    register int i;
    register int *aptr; register int *bptr;

#line 72 "./dct.sc"
    register int a0; register int a1; register int a2; register int a3;
    register int b0; register int b1; register int b2; register int b3;
    register int c0; register int c1; register int c2; register int c3;




    for(i = 0; i < 8; i++ )
    {   
	aptr = x + i;
	bptr = aptr + 56;

	a0 = ((( *aptr +  *bptr)) << (2));
	c3 = ((( *aptr -  *bptr)) << (2));
	aptr += 8;
	bptr -= 8;
	a1 = ((( *aptr +  *bptr)) << (2));
	c2 = ((( *aptr -  *bptr)) << (2));
	aptr += 8;
	bptr -= 8;
	a2 = ((( *aptr +  *bptr)) << (2));
	c1 = ((( *aptr -  *bptr)) << (2));
	aptr += 8;
	bptr -= 8;
	a3 = ((( *aptr +  *bptr)) << (2));
	c0 = ((( *aptr -  *bptr)) << (2));

	b0 = a0 + a3;
	b1 = a1 + a2;
	b2 = a1 - a2;
	b3 = a0 - a3;

	aptr = ( &y[0]) + i;

	 *aptr = (((362l * (b0 + b1))) >> (9));
	aptr[32] = (((362l * (b0 - b1))) >> (9));

	aptr[16] = ((((196l * b2) + (473l * b3))) >> (9));
	aptr[48] = ((((196l * b3) - (473l * b2))) >> (9));

	b0 = (((362l * (c2 - c1))) >> (9));
	b1 = (((362l * (c2 + c1))) >> (9));

	a0 = c0 + b0;
	a1 = c0 - b0;
	a2 = c3 - b1;
	a3 = c3 + b1;

	aptr[8] = ((((100l * a0) + (502l * a3))) >> (9));
	aptr[24] = ((((426l * a2) - (284l * a1))) >> (9));
	aptr[40] = ((((426l * a1) + (284l * a2))) >> (9));
	aptr[56] = ((((100l * a3) - (502l * a0))) >> (9));
    }

    for(i = 0; i < 8; i++ )
    {   
	aptr = ( &y[0]) + ((i) << (3));
	bptr = aptr + 7;

	c3 = ((( *(aptr) -  *(bptr))) >> (1));
	a0 = ((( *(aptr++ ) +  *(bptr-- ))) >> (1));
	c2 = ((( *(aptr) -  *(bptr))) >> (1));
	a1 = ((( *(aptr++ ) +  *(bptr-- ))) >> (1));
	c1 = ((( *(aptr) -  *(bptr))) >> (1));
	a2 = ((( *(aptr++ ) +  *(bptr-- ))) >> (1));
	c0 = ((( *(aptr) -  *(bptr))) >> (1));
	a3 = ((( *(aptr) +  *(bptr))) >> (1));

	b0 = a0 + a3;
	b1 = a1 + a2;
	b2 = a1 - a2;
	b3 = a0 - a3;

	aptr = ( &y[0]) + ((i) << (3));

	 *aptr = (((362l * (b0 + b1))) >> (9));
	aptr[4] = (((362l * (b0 - b1))) >> (9));
	aptr[2] = ((((196l * b2) + (473l * b3))) >> (9));
	aptr[6] = ((((196l * b3) - (473l * b2))) >> (9));

	b0 = (((362l * (c2 - c1))) >> (9));
	b1 = (((362l * (c2 + c1))) >> (9));

	a0 = c0 + b0;
	a1 = c0 - b0;
	a2 = c3 - b1;
	a3 = c3 + b1;

	aptr[1] = ((((100l * a0) + (502l * a3))) >> (9));
	aptr[3] = ((((426l * a2) - (284l * a1))) >> (9));
	aptr[5] = ((((426l * a1) + (284l * a2))) >> (9));
	aptr[7] = ((((100l * a3) - (502l * a0))) >> (9));
    }



    for(i = 0 , aptr = ( &y[0]); i < 64; i++  , aptr++ )
	 *aptr = ((( *aptr < 0) ? ( *aptr - 4) : ( *aptr + 4)) / 8);
}

#line 411 "tb.cc"
PreshiftDctMatrix::PreshiftDctMatrix(int (&mi)[64], int (&mo)[64], int (&shift))
    : mi(mi), mo(mo), shift(shift)
{   /* nothing */
}

PreshiftDctMatrix::~PreshiftDctMatrix(void)
{   /* nothing */
}

#line 177 "./dct.sc"
void PreshiftDctMatrix::main(void)
{   
    int i;
    for(i = 0; i < 64; i++ )
	mo[i] = mi[i] - shift;
}

#line 429 "tb.cc"
BoundDctMatrix::BoundDctMatrix(int (&mi)[64], int (&mo)[64], int (&bound))
    : mi(mi), mo(mo), bound(bound)
{   /* nothing */
}

BoundDctMatrix::~BoundDctMatrix(void)
{   /* nothing */
}

#line 189 "./dct.sc"
void BoundDctMatrix::main(void)
{   
    int i;
    for(i = 0; i < 64; i++ ) {
	if (mi[i] <  -bound)
	    mo[i] =  -bound;
	else  if (mi[i] > bound)
		mo[i] = bound;
	    else 
		mo[i] = mi[i];
    }
}

#line 453 "tb.cc"
DCT::DCT(int (&HData)[64], int (&DData)[64])
    : HData(HData), DData(DData),
    _scc_const_port_0(1023),
    _scc_const_port_1(128),
    boundDctMatrix(DDataDct, DData, _scc_const_port_0),
    chenDct(HDataDct, DDataDct),
    preshiftDctMatrix(HData, HDataDct, _scc_const_port_1)
{   /* nothing */
}

DCT::~DCT(void)
{   /* nothing */
}

#line 213 "./dct.sc"
void DCT::main(void) {
    preshiftDctMatrix.main();
    chenDct.main();
    boundDctMatrix.main();
}

#line 475 "tb.cc"
InitTable::InitTable(const int (&bts)[16], const int (&hvls)[162], struct huffman_standard_structure (&xhuff))
    : bts(bts), hvls(hvls), xhuff(xhuff)
{   /* nothing */
}

InitTable::~InitTable(void)
{   /* nothing */
}

#line 51 "./default.sc"
void InitTable::main(void)
{   
    int i;
    int accum;

    for(accum = 0 , i = 0; i < 16; i++ )
    {   
	accum += bts[i];
	xhuff.bits[i + 1] = bts[i];
    }
    for(i = 0; i < accum; i++ )
    {   
	xhuff.huffval[i] = hvls[i];
    }
}

#line 502 "tb.cc"
SizeTable::SizeTable(struct huffman_standard_structure (&xhuff), int (&huffsize)[257], int (&lastp))
    : xhuff(xhuff), huffsize(huffsize), lastp(lastp)
{   /* nothing */
}

SizeTable::~SizeTable(void)
{   /* nothing */
}

#line 72 "./default.sc"
void SizeTable::main(void)
{   
    int i; int j; int p;

    for(p = 0 , i = 1; i < 17; i++ ) {
	for(j = 1; j <= xhuff.bits[i]; j++ ) {
	    huffsize[p++ ] = i;
	}
    }
    huffsize[p] = 0;
    lastp = p;
}

#line 526 "tb.cc"
CodeTable::CodeTable(int (&huffsize)[257], int (&huffcode)[257])
    : huffsize(huffsize), huffcode(huffcode)
{   /* nothing */
}

CodeTable::~CodeTable(void)
{   /* nothing */
}

#line 89 "./default.sc"
void CodeTable::main(void)
{   
    int code; int p; int size;

    p = 0;
    code = 0;
    size = huffsize[0];
    while(1)
    {   
	do  {
	    huffcode[p++ ] = code++ ;
	}
	while((huffsize[p] == size) && (p < 257));
	if ( !huffsize[p]) {
	    break;
	}
	do  {
	    code <<= 1;
	    size++ ;
	}
	while(huffsize[p] != size);
    }
}

#line 561 "tb.cc"
OrderCodes::OrderCodes(int (&lastp), struct huffman_standard_structure (&xhuff), struct huffman_encoder (&ehuff), int (&huffsize)[257], int (&huffcode)[257])
    : lastp(lastp), xhuff(xhuff), ehuff(ehuff), huffsize(huffsize), huffcode(huffcode)
{   /* nothing */
}

OrderCodes::~OrderCodes(void)
{   /* nothing */
}

#line 118 "./default.sc"
void OrderCodes::main(void)
{   
    int index; int p;

    for(p = 0; p < lastp; p++ )
    {   
	index = xhuff.huffval[p];
	ehuff.ehufco[index] = huffcode[p];
	ehuff.ehufsi[index] = huffsize[p];
    }
}

#line 584 "tb.cc"
SpecifiedHuffman::SpecifiedHuffman(const int (&bts)[16], const int (&hvls)[162], struct huffman_standard_structure (&Xhuff), struct huffman_encoder (&Ehuff))
    : bts(bts), hvls(hvls), Xhuff(Xhuff), Ehuff(Ehuff),
    lastp(0),
    codeTable(huffsize, huffcode),
    initTable(bts, hvls, Xhuff),
    orderCodes(lastp, Xhuff, Ehuff, huffsize, huffcode),
    sizeTable(Xhuff, huffsize, lastp)
{   /* nothing */
}

SpecifiedHuffman::~SpecifiedHuffman(void)
{   /* nothing */
}

#line 144 "./default.sc"
void SpecifiedHuffman::main(void)
{   
    initTable.main();
    sizeTable.main();
    codeTable.main();
    orderCodes.main();
}

#line 608 "tb.cc"
JpegDefaultHuffman::JpegDefaultHuffman(struct huffman_standard_structure (&DCXhuff), struct huffman_encoder (&DCEhuff), struct huffman_standard_structure (&ACXhuff), struct huffman_encoder (&ACEhuff))
    : DCXhuff(DCXhuff), DCEhuff(DCEhuff), ACXhuff(ACXhuff), ACEhuff(ACEhuff),
    sh1(LuminanceDCBits, LuminanceDCValues, DCXhuff, DCEhuff),
    sh2(LuminanceACBits, LuminanceACValues, ACXhuff, ACEhuff)
{   /* nothing */
}

JpegDefaultHuffman::~JpegDefaultHuffman(void)
{   /* nothing */
}

#line 160 "./default.sc"
void JpegDefaultHuffman::main(void)
{   
    { _specc::fork _scc_fork_0(&sh1), _scc_fork_1(&sh2); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, ((_specc::fork*)0));
    }
}

#line 629 "tb.cc"
Design::Design(i_int_receiver (&chHeader), i_byte_receiver (&chPixel), i_byte_sender (&chData))
    : chHeader(chHeader), chPixel(chPixel), chData(chData),
    jpeg(chHeader, chPixel, chData)
{   /* nothing */
}

Design::~Design(void)
{   /* nothing */
}

#line 17 "./design.sc"
void Design::main(void)
{   
    { _specc::fork _scc_fork_0(&jpeg); _specc::pipe(
	    &_scc_fork_0, ((_specc::fork*)0), ((void*)0));
    }
}

#line 648 "tb.cc"
JpegEncodeStripe::JpegEncodeStripe(int (&mduHigh), unsigned char *(&stripe), int (&MDUWide), struct huffman_encoder (&DCEhuff), struct huffman_encoder (&ACEhuff), ISendBits (&chData))
    : mduHigh(mduHigh), stripe(stripe), MDUWide(MDUWide), DCEhuff(DCEhuff), ACEhuff(ACEhuff), chData(chData),
    dct(hdata.Value[0], ddata.Value[1]),
    handleData(mduWide, mduHigh, stripe, MDUWide, hdata.Value[1]),
    huffmanEncode(qdata.Value[0], DCEhuff, ACEhuff, chData),
    quantization(ddata.Value[0], qdata.Value[1])
{   /* nothing */
}

JpegEncodeStripe::~JpegEncodeStripe(void)
{   /* nothing */
}

#line 30 "./encode.sc"
void JpegEncodeStripe::main(void)
{   
    { _specc::fork _scc_fork_0(&handleData), _scc_fork_1(&dct), _scc_fork_2(&quantization), _scc_fork_3(&huffmanEncode); unsigned int _scc_first=1, _scc_last=1; for(mduWide = 0; mduWide < MDUWide; mduWide++ ){ _specc::pipe(4, _scc_first, _scc_last, 

		&_scc_fork_0, 
		&_scc_fork_1, 
		&_scc_fork_2, 
		&_scc_fork_3, &ddata, &hdata, &qdata, ((void*)0)); if (_scc_last<4) _scc_last++;
	} while (_scc_first++<_scc_last){ _specc::pipe(4, _scc_first, _scc_last, &_scc_fork_0, &_scc_fork_1, &_scc_fork_2, &_scc_fork_3, &ddata, &hdata, &qdata, ((void*)0)); if (_scc_last<4) _scc_last++;
	}
    }
}

#line 676 "tb.cc"
JpegEncode::JpegEncode(i_byte_receiver (&chPixel), int (&ImageWidth), int (&ImageHeight), struct huffman_encoder (&DCEhuff), struct huffman_encoder (&ACEhuff), ISendBits (&chData))
    : chPixel(chPixel), ImageWidth(ImageWidth), ImageHeight(ImageHeight), DCEhuff(DCEhuff), ACEhuff(ACEhuff), chData(chData),
    encodeStripe(mduHigh, stripe.Value[0], MDUWide.Value[0], DCEhuff, ACEhuff, chData),
    receiveData(chPixel, mduHigh, ImageWidth, ImageHeight, MDUWide.Value[1], stripe.Value[1])
{   /* nothing */
}

JpegEncode::~JpegEncode(void)
{   /* nothing */
}

#line 60 "./encode.sc"
void JpegEncode::main(void)
{   
    { _specc::fork _scc_fork_0(&receiveData), _scc_fork_1(&encodeStripe); unsigned int _scc_first=1, _scc_last=1; for(mduHigh = 0 , MDUHigh = (ImageHeight + 7) >> 3; mduHigh < MDUHigh; mduHigh++ ){ _specc::pipe(2, _scc_first, _scc_last, 

		&_scc_fork_0, 
		&_scc_fork_1, &MDUWide, &stripe, ((void*)0)); if (_scc_last<2) _scc_last++;
	} while (_scc_first++<_scc_last){ _specc::pipe(2, _scc_first, _scc_last, &_scc_fork_0, &_scc_fork_1, &MDUWide, &stripe, ((void*)0)); if (_scc_last<2) _scc_last++;
	}
    }
}

#line 700 "tb.cc"
ReceiveData::ReceiveData(i_byte_receiver (&chPixel), int (&mduHigh), int (&ImageWidth), int (&ImageHeight), int (&MDUWide), unsigned char *(&stripe))
    : chPixel(chPixel), mduHigh(mduHigh), ImageWidth(ImageWidth), ImageHeight(ImageHeight), MDUWide(MDUWide), stripe(stripe)
{   /* nothing */
}

ReceiveData::~ReceiveData(void)
{   /* nothing */
}

#line 18 "./handle.sc"
void ReceiveData::main(void)
{   
    int MDUs;
    int i; int j;
    char temp;
    unsigned char *buf;


    MDUs = (ImageWidth + 7) >> 3;


    buf = (unsigned char *)calloc(64 * MDUs, sizeof(char));


    for(i = 0; i < 8; i++ ) {
	for(j = 0; j < MDUs * 8; j++ ) {
	    if ((j < ImageWidth) && (mduHigh * 8 + i < ImageHeight)) {



		chPixel.receive( &temp);



		buf[i * MDUs * 8 + j] = temp;
	    }
	    else  {
		buf[i * MDUs * 8 + j] = buf[i * MDUs * 8 + ImageWidth - 1];
	    }
	}
    }


    MDUWide = MDUs;
    stripe = buf;
}

#line 748 "tb.cc"
HandleData::HandleData(int (&mduWide), int (&mduHigh), unsigned char *(&stripe), int (&MDUWide), int (&HData)[64])
    : mduWide(mduWide), mduHigh(mduHigh), stripe(stripe), MDUWide(MDUWide), HData(HData),
    block(0)
{   /* nothing */
}

HandleData::~HandleData(void)
{   /* nothing */
}

#line 64 "./handle.sc"
void HandleData::main(void)
{   
    int i; int j;

#line 75 "./handle.sc"
    for(i = 0; i < 8; i++ ) {
	for(j = 0; j < 8; j++ ) {
	    HData[i * 8 + j] = stripe[i * MDUWide * 8 + mduWide * 8 + j];
	}
    }

#line 88 "./handle.sc"
    if (mduWide == (MDUWide - 1)) free(stripe);
}

#line 775 "tb.cc"
JpegHeader::JpegHeader(int (&ImageWidth), int (&ImageHeight), struct huffman_standard_structure (&DCXhuff), struct huffman_standard_structure (&ACXhuff), ISendBits (&chData))
    : ImageWidth(ImageWidth), ImageHeight(ImageHeight), DCXhuff(DCXhuff), ACXhuff(ACXhuff), chData(chData)
{   /* nothing */
}

JpegHeader::~JpegHeader(void)
{   /* nothing */
}

#line 44 "./header.sc"
void JpegHeader::WriteAPP0()
{   
    chData.WriteMarker(224);


    chData.WriteWord(16);


    chData.WriteByte('J');
    chData.WriteByte('F');
    chData.WriteByte('I');
    chData.WriteByte('F');
    chData.WriteByte(0);


    chData.WriteWord(258);


    chData.WriteByte(2);


    chData.WriteWord(29);


    chData.WriteWord(29);


    chData.WriteWord(0);
}

#line 117 "./header.sc"
void JpegHeader::WriteDHT()
{   
    chData.WriteMarker(196);

    chData.WriteWord(4 + 32 + 12 + 162);



    chData.WriteByte(0);
    WriteHuffman( &DCXhuff);



    chData.WriteByte(16);
    WriteHuffman( &ACXhuff);
}

#line 100 "./header.sc"
void JpegHeader::WriteDQT()
{   
    int i;

    chData.WriteMarker(219);


    chData.WriteWord(67);


    chData.WriteByte(0);

    for(i = 0; i < 64; i++ ) {
	chData.WriteByte(QuantizationMatrix[IZigzagIndex[i]]);
    }
}

#line 29 "./header.sc"
void JpegHeader::WriteHuffman(struct huffman_standard_structure *xhuff)
{   
    int accum; int i;

    for(accum = 0 , i = 1; i <= 16; i++ )
    {   
	chData.WriteByte(xhuff->bits[i]);
	accum += xhuff->bits[i];
    }
    for(i = 0; i < accum; i++ )
    {   
	chData.WriteByte(xhuff->huffval[i]);
    }
}

#line 74 "./header.sc"
void JpegHeader::WriteSOF(void)
{   
    chData.WriteMarker(192);


    chData.WriteWord(11);


    chData.WriteByte(8);


    chData.WriteWord(ImageHeight);
    chData.WriteWord(ImageWidth);


    chData.WriteByte(1);



    chData.WriteByte(1);

    chData.WriteByte(17);

    chData.WriteByte(0);
}

#line 134 "./header.sc"
void JpegHeader::WriteSOS()
{   
    chData.WriteMarker(218);


    chData.WriteWord(8);


    chData.WriteByte(1);


    chData.WriteByte(1);


    chData.WriteByte(0);


    chData.WriteByte(0);


    chData.WriteByte(63);


    chData.WriteByte(0);
}


void JpegHeader::main(void)
{   




    chData.WriteMarker(216);
    WriteAPP0();
    WriteSOF();
    WriteDQT();
    WriteDHT();
    WriteSOS();
}

#line 937 "tb.cc"
ZigzagMatrix::ZigzagMatrix(int (&imatrix)[64], int (&omatrix)[64])
    : imatrix(imatrix), omatrix(omatrix)
{   /* nothing */
}

ZigzagMatrix::~ZigzagMatrix(void)
{   /* nothing */
}

#line 119 "./huff.sc"
void ZigzagMatrix::main(void)
{   
    int i; int z;

#line 133 "./huff.sc"
    for(i = 0; i < 64; i++ ) {
	z = ZigzagIndex[i];
	omatrix[z] = imatrix[i];
    }
}

#line 959 "tb.cc"
EncodeDC::EncodeDC(int (&matrix)[64], struct huffman_encoder (&Ehuff), ISendBits (&chData))
    : matrix(matrix), Ehuff(Ehuff), chData(chData),
    LastDC(0)
{   /* nothing */
}

EncodeDC::~EncodeDC(void)
{   /* nothing */
}

#line 148 "./huff.sc"
void EncodeDC::main(void)
{   
    int coef; int cofac; int diff; int s;

#line 157 "./huff.sc"
    coef = matrix[0];

    diff = coef - LastDC;
    LastDC = coef;
    cofac = abs(diff);
    if (cofac < 256) {
	s = csize[cofac];
    }
    else  {
	cofac = cofac >> 8;
	s = csize[cofac] + 8;
    }

    EncodeHuffman( &Ehuff, s, chData);
    if (diff < 0) {
	diff-- ;
    }

    chData.WriteBits(s, diff);
}

#line 997 "tb.cc"
EncodeAC::EncodeAC(int (&matrix)[64], struct huffman_encoder (&Ehuff), ISendBits (&chData))
    : matrix(matrix), Ehuff(Ehuff), chData(chData)
{   /* nothing */
}

EncodeAC::~EncodeAC(void)
{   /* nothing */
}

#line 183 "./huff.sc"
void EncodeAC::main(void)
{   
    int cofac; int i; int k; int r; int ssss;

#line 192 "./huff.sc"
    for(k = r = 0;  ++k < 64; )
    {   
	cofac = abs(matrix[k]);
	if (cofac < 256) {
	    ssss = csize[cofac];
	}
	else  {
	    cofac = cofac >> 8;
	    ssss = csize[cofac] + 8;
	}

	if (matrix[k] == 0) {
	    if (k == 64 - 1) {
		EncodeHuffman( &Ehuff, 0, chData);
		break;
	    }
	    r++ ;
	}
	else  {
	    while(r > 15) {
		EncodeHuffman( &Ehuff, 240, chData);
		r -= 16;
	    }
	    i = 16 * r + ssss;
	    r = 0;
	    EncodeHuffman( &Ehuff, i, chData);
	    if (matrix[k] < 0)
		chData.WriteBits(ssss, matrix[k] - 1);
	    else 
		chData.WriteBits(ssss, matrix[k]);
	}
    }
}

#line 1047 "tb.cc"
HuffmanEncode::HuffmanEncode(int (&QData)[64], struct huffman_encoder (&DCEhuff), struct huffman_encoder (&ACEhuff), ISendBits (&chData))
    : QData(QData), DCEhuff(DCEhuff), ACEhuff(ACEhuff), chData(chData),
    encodeAC(OData, ACEhuff, chData),
    encodeDC(OData, DCEhuff, chData),
    zigzagMatrix(QData, OData)
{   /* nothing */
}

HuffmanEncode::~HuffmanEncode(void)
{   /* nothing */
}

#line 238 "./huff.sc"
void HuffmanEncode::main(void) {
    zigzagMatrix.main();
    encodeDC.main();
    encodeAC.main();
}

#line 1067 "tb.cc"
Input::Input(char *(&ifname), i_int_sender (&Header), i_byte_sender (&Pixel))
    : ifname(ifname), Header(Header), Pixel(Pixel)
{   /* nothing */
}

Input::~Input(void)
{   /* nothing */
}

#line 113 "./io.sc"
int Input::IsBmpFile()
{   
    int t = 16973;
    int c;
    c = ReadWord();
    fseek(ifp,  -2, 1);

    return t == c;
}

void Input::ReadBmpHeader()
{   
    int count; int i;

    if ( !IsBmpFile()) {
	error("This file is not compatible with BMP format.\n");
    }


    BmpFileHeader.bfType = ReadWord();
    BmpFileHeader.bfSize = ReadRevDWord();
    BmpFileHeader.bfReserved1 = ReadRevWord();
    BmpFileHeader.bfReserved2 = ReadRevWord();
    BmpFileHeader.bfOffBits = ReadRevDWord();


    BmpInfoHeader.biSize = ReadRevDWord();
    BmpInfoHeader.biWidth = ReadRevDWord();
    BmpInfoHeader.biHeight = ReadRevDWord();
    BmpInfoHeader.biPlanes = ReadRevWord();
    BmpInfoHeader.biBitCount = ReadRevWord();

    if (BmpInfoHeader.biSize > 12) {
	BmpInfoHeader.biCompression = ReadRevDWord();
	BmpInfoHeader.biSizeImage = ReadRevDWord();
	BmpInfoHeader.biXPelsPerMeter = ReadRevDWord();
	BmpInfoHeader.biYPelsPerMeter = ReadRevDWord();
	BmpInfoHeader.biClrUsed = ReadRevDWord();
	BmpInfoHeader.biClrImportant = ReadRevDWord();


	count = BmpFileHeader.bfOffBits - ftell(ifp);
	count >>= 2;

	BmpColors = (struct tagRGBTRIPLE *)calloc(sizeof(struct tagRGBTRIPLE), count);

	for(i = 0; i < count; i++ ) {
	    BmpColors[i].B = ReadByte();
	    BmpColors[i].G = ReadByte();
	    BmpColors[i].R = ReadByte();
	    ReadByte();
	}
    }
    else  {

	count = BmpFileHeader.bfOffBits - ftell(ifp);
	count /= 3;

	BmpColors = (struct tagRGBTRIPLE *)calloc(sizeof(struct tagRGBTRIPLE), count);

	for(i = 0; i < count; i++ ) {
	    BmpColors[i].B = ReadByte();
	    BmpColors[i].G = ReadByte();
	    BmpColors[i].R = ReadByte();
	}
    }


    if (BmpInfoHeader.biBitCount == 24) {
	BmpScanWidth = ((BmpInfoHeader.biWidth * 3 + 3) >> 2) << 2;
	BmpScanHeight = BmpInfoHeader.biHeight;
    }
    else  {
	BmpScanWidth = ((BmpInfoHeader.biWidth + 3) >> 2) << 2;
	BmpScanHeight = BmpInfoHeader.biHeight;
    }
}

#line 86 "./io.sc"
int Input::ReadByte()
{   
    return fgetc(ifp);
}

#line 102 "./io.sc"
long int Input::ReadDWord()
{   
    long int c;
    c = fgetc(ifp) << 24;
    c |= fgetc(ifp) << 16;
    c |= fgetc(ifp) << 8;
    c |= fgetc(ifp);

    return c;
}

#line 91 "./io.sc"
long int Input::ReadRevDWord()
{   
    long int c;
    c = fgetc(ifp);
    c |= fgetc(ifp) << 8;
    c |= fgetc(ifp) << 16;
    c |= fgetc(ifp) << 24;

    return c;
}

#line 68 "./io.sc"
int Input::ReadRevWord()
{   
    int c;
    c = fgetc(ifp);
    c |= fgetc(ifp) << 8;

    return c;
}

int Input::ReadWord()
{   
    int c;
    c = fgetc(ifp) << 8;
    c |= fgetc(ifp);

    return c;
}

#line 192 "./io.sc"
void Input::main(void)
{   
    int c; int r;
    char buf;


    ifp = fopen(ifname, "rb");
    if ( !ifp) {
	error("Cannot open input file %s\n", ifname);
    }


    ReadBmpHeader();

#line 211 "./io.sc"
    Header.send(BmpInfoHeader.biWidth);
    Header.send(BmpInfoHeader.biHeight);

#line 220 "./io.sc"
    for(r = BmpInfoHeader.biHeight - 1; r >= 0; r-- )
    {   

	fseek(ifp, BmpFileHeader.bfOffBits + r * BmpScanWidth, 0);


	for(c = 0; c < BmpInfoHeader.biWidth; c++ ) {

	    if (ferror(ifp) || (fread( &buf, 1, 1, ifp) != 1)) {
		error("Error reading data from file %s\n", ifname);
	    }

#line 237 "./io.sc"
	    Pixel.send(buf);
	}
    }

#line 245 "./io.sc"
    fclose(ifp);
}

#line 1246 "tb.cc"
Output::Output(char *(&ofname), i_byte_receiver (&Data))
    : ofname(ofname), Data(Data)
{   /* nothing */
}

Output::~Output(void)
{   /* nothing */
}

#line 265 "./io.sc"
void Output::main(void)
{   
    bool marker; bool running;
    char buf;


    if (ofname) {
	ofp = fopen(ofname, "wb");
	if ( !ofp) {
	    error("Cannot open output file %s\n", ofname);
	}
    }
    else  {
	ofp = stdOut();
    }


    running = true;
    marker = false;
    while(running)
    {   




	Data.receive( &buf);

#line 296 "./io.sc"
	if ((fwrite( &buf, 1, 1, ofp) != 1) || ferror(ofp)) {
	    error("Error writing to file %s\n", ofname);
	}


	if (marker) {

	    running = ((unsigned char)buf != 217);
	    marker = false;
	}
	else  {
	    marker = ((unsigned char)buf == 255);
	}
    }


    fclose(ofp);


    _specc::waitfor((1000000));
    exit(0);
}

#line 1308 "tb.cc"
JpegStart::JpegStart(i_int_receiver (&chHeader), int (&ImageWidth), int (&ImageHeight))
    : chHeader(chHeader), ImageWidth(ImageWidth), ImageHeight(ImageHeight)
{   /* nothing */
}

JpegStart::~JpegStart(void)
{   /* nothing */
}

#line 20 "./jpeg.sc"
void JpegStart::main(void)
{   
    int height; int width;

#line 28 "./jpeg.sc"
    chHeader.receive( &width);
    chHeader.receive( &height);
    ImageWidth = width;
    ImageHeight = height;
}

#line 1330 "tb.cc"
JpegInit::JpegInit(i_int_receiver (&chHeader), ISendBits (&chData), struct huffman_encoder (&DCEhuff), struct huffman_encoder (&ACEhuff), int (&ImageWidth), int (&ImageHeight))
    : chHeader(chHeader), chData(chData), DCEhuff(DCEhuff), ACEhuff(ACEhuff), ImageWidth(ImageWidth), ImageHeight(ImageHeight),
    header(ImageWidth, ImageHeight, DCXhuff, ACXhuff, chData),
    huffman(DCXhuff, DCEhuff, ACXhuff, ACEhuff),
    start(chHeader, ImageWidth, ImageHeight)
{   /* nothing */
}

JpegInit::~JpegInit(void)
{   /* nothing */
}

#line 56 "./jpeg.sc"
void JpegInit::main(void)
{   
    start.main();
    huffman.main();
    header.main();
}

#line 1351 "tb.cc"
JpegEnd::JpegEnd(ISendBits (&chData))
    : chData(chData)
{   /* nothing */
}

JpegEnd::~JpegEnd(void)
{   /* nothing */
}

#line 68 "./jpeg.sc"
void JpegEnd::main(void)
{   
    chData.WriteBits( -1, 0);
    chData.WriteMarker(217);
}

#line 1368 "tb.cc"
Jpeg::Jpeg(i_int_receiver (&chHeader), i_byte_receiver (&chPixel), i_byte_sender (&chData))
    : chHeader(chHeader), chPixel(chPixel), chData(chData),
    bitAdapter(chData),
    encode(chPixel, imageWidth, imageHeight, DCEhuff, ACEhuff, bitAdapter),
    end(bitAdapter),
    init(chHeader, bitAdapter, DCEhuff, ACEhuff, imageWidth, imageHeight)
{   /* nothing */
}

Jpeg::~Jpeg(void)
{   /* nothing */
}

#line 96 "./jpeg.sc"
void Jpeg::main(void)
{   
    init.main();
    encode.main();
    end.main();
}

#line 1390 "tb.cc"
Quantization::Quantization(int (&DData)[64], int (&QData)[64])
    : DData(DData), QData(QData)
{   /* nothing */
}

Quantization::~Quantization(void)
{   /* nothing */
}

#line 14 "./quant.sc"
void Quantization::main(void)
{   
    int i; int m; int q;
    for(i = 0; i < 64; i++ ) {
	m = DData[i];
	q = QuantizationMatrix[i];
	if (m > 0) {
	    QData[i] = (m + q / 2) / q;
	}
	else  {
	    QData[i] = (m - q / 2) / q;
	}
    }
}

#line 1416 "tb.cc"
Main::Main(void)
    : design(header, pixel, data),
    input(ifname, header, pixel),
    output(ofname, data)
{   /* nothing */
}

Main::~Main(void)
{   /* nothing */
}

#line 26 "tb.sc"
int Main::main(int argc, char **argv)
{   

    if (argc < 2) {
	error("Usage: %s infile [ outfile ]\n", argv[0]);
    }
    ifname = argv[1];
    if (argc >= 3) {
	ofname = argv[2];
    }
    else 

#line 35 "tb.sc"
    {   
	ofname = 0;
    }


    { _specc::fork _scc_fork_0(&input), _scc_fork_1(&design), _scc_fork_2(&output); _specc::par(
	    &_scc_fork_0, 
	    &_scc_fork_1, 
	    &_scc_fork_2, ((_specc::fork*)0));
    }

    return 0;
}

#line 1456 "tb.cc"
Main _scc_main;

int main(int argc, char **argv)
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main(argc, argv);
    _specc::end();
    return(_scc_main_return);
}

// function definitions //////////////////////////////////////////////

#line 57 "./huff.sc"
void PrintTable(int *table)
{   
    int i; int j;

    for(i = 0; i < 16; i++ )
    {   
	for(j = 0; j < 16; j++ )
	{   
	    msg("%2x ",  *(table++ ));
	}
	msg("\n");
    }
}

void PrintHuffman(struct huffman_encoder *ehuff, struct huffman_standard_structure *xhuff)
{   
    int i;

    if (xhuff)
    {   
	msg("Bits: [length:number]\n");
	for(i = 1; i < 9; i++ )
	{   
	    msg("[%d:%d]", i, xhuff->bits[i]);
	}
	msg("\n");
	for(i = 9; i < 17; i++ )
	{   
	    msg("[%d:%d]", i, xhuff->bits[i]);
	}
	msg("\n");

	msg("Huffval:\n");
	PrintTable(xhuff->huffval);
    }
    if (ehuff)
    {   
	msg("Ehufco:\n");
	PrintTable(ehuff->ehufco);
	msg("Ehufsi:\n");
	PrintTable(ehuff->ehufsi);
    }
}


void EncodeHuffman(struct huffman_encoder *ehuff, int value, ISendBits (&chData))
{   
    if (ehuff->ehufsi[value]) {
	chData.WriteBits(ehuff->ehufsi[value], ehuff->ehufco[value]);
    }
    else  {
	msg("Null Code for [%d] Encountered:\n", value);
	msg("*** Dumping Huffman Table ***\n");
	PrintHuffman(ehuff, 0);
	msg("***\n");
	exit( -1);
    }
}

//////////////////////////////////////////////////////////////////////
// End of file tb.cc
//////////////////////////////////////////////////////////////////////
